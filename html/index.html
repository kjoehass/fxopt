<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>fxopt: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">fxopt
   </div>
   <div id="projectbrief">A floating-point to fixed-point arithmetic conversion plugin for gcc</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">fxopt Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>K. Joseph Hass </dd></dl>
<dl class="section date"><dt>Date</dt><dd>Created: 2014-01-03T15:46:24-0500 </dd>
<dd>
Last modified: 2014-04-12T15:30:29-0400</dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>Copyright (C) 2014 Kenneth Joseph Hass</dd>
<dd>
This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</dd>
<dd>
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</dd></dl>
<h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>Fxopt is a plugin for gcc that converts floating-point arithmetic to fixed-point arithmetic. The conversion formats the operands for each operation so that overflow cannot occur, and attempts to do so while preserving the maximum possible accuracy of the result. The end result of this process is an object file, as is normally the case when running gcc. The user may also choose to convert the object file to an assembly code file. For verification purposes, the fixed-point code can be converted into a standard C language version that corresponds exactly to the behavior of the object/assembly version.</p>
<p>The plugin manipulates the GIMPLE intermediate format used by gcc, replacing floating-point variables and operators with fixed-point variables and operators. New statements are inserted into the code as necessary to reformat variables before performing arithmetic operations.</p>
<p><em>fxopt</em> supports several optional optimization methods that can be enabled or disabled via command line switches. These are </p>
<ul>
<li>Conversion of single-precision multiplications to double precision. </li>
<li>Conversion of division by a constant to multiplication by the inverse. </li>
<li>Range estimation using interval arithmetic </li>
<li>Range estimation using affine arithmetic </li>
<li>Rounding before truncation </li>
<li>Rounding with a run-time check for correcting negative values</li>
</ul>
<p>In many cases, fxopt can generate a fixed-point function with accuracy comparable to single-precision floating-point while reducing the execution time by an order of magnitude. If floating-point accuracy is not needed then even greater improvements in run time can be achieved.</p>
<h1><a class="anchor" id="back"></a>
Fixed-point arithmetic</h1>
<p>The most primitive numerical datatype in a digital computer is the <em>integer</em>. The usual default is that an integer is assumed to be <em>signed</em>, which means that it can represent either positive or negative values. Signed integers are almost always in two's-complement format. For an <img class="formulaInl" alt="$N$" src="form_1.png"/>-bit signed integer the range of representable values is from <img class="formulaInl" alt="$-2^{N-1}$" src="form_2.png"/> to <img class="formulaInl" alt="$2^{N-1}-1$" src="form_3.png"/>. Although the terminology is not quite correct, we often refer to the most significant (leftmost) bit of a two's-complement value as the <em>sign bit</em>, because this bit is always a 1 if it represents a negative integer.</p>
<p>Real numbers are typically represented digitally as <em>floating-point</em> values. A floating-point number actually consists of three separate values: the mantissa,the exponent, and the sign. If we ignore the details, the real number represented by a floating-point value is equal to </p>
<p class="formulaDsp">
<img class="formulaDsp" alt="\[Mantissa \times 2^{Exponent}\]" src="form_4.png"/>
</p>
<p> Because they include an exponent, floating-point numbers have an extremely wide range when compared to integers. However, keeping track of the exponent and performing arithmetic operations on floating-point values is much more complicated than performing the same operations on integers.</p>
<p>Fixed-point arithmetic is a method of performing calculations that tries to use integer arithmetic operators when working with real numbers. Fixed-point values have an exponent, but the exponent is determined at compile time and the exponent for a given variable never changes at run time. The exponent is always an integer power of 2, so you can also say that the exponent determines the location of the (implied) binary point location in the value. Since the exponent never changes for a given variable it is also true that the radix point never moves, so these values are called <em>fixed-point</em> values.</p>
<p>A simple 16-bit fixed-point number is shown in the figure below. The most-significant bit (MSB) is reserved for conveying sign information and is marked with an <b>S</b>. In this case we have decided that the binary point location is between 4 bits on the left and 12 bits on the right. The bit immediately to the left of the binary point has a place value of <img class="formulaInl" alt="$2^0$" src="form_5.png"/> (the "ones" bit). The next bit to the left has a place value of <img class="formulaInl" alt="$2^1$" src="form_6.png"/> (the "twos" bit), and the next bit moving left has a place value of <img class="formulaInl" alt="$2^2$" src="form_7.png"/> (the "fours" bit). These bits are like the "ones", "tens", and "hundreds" digits in the decimal arithmetic we learned as children. Since all of the bits to the left of the binary point have a place value that is equal to an integer these bits will be collectively known as the <em>integer bits</em>.</p>
<div class="image">
<img src="Qif_format.png" alt="Qif_format.png"/>
<div class="caption">
Simple fixed-point format</div></div>
<p> The bit that is immediately to the right of the binary point has a place value of <img class="formulaInl" alt="$2^{-1}$" src="form_8.png"/>, or one-half. As we move to the right the place value is halved for each bit, so the right-most least-significant bit (LSB) has a place value of <img class="formulaInl" alt="$2^{-12}$" src="form_9.png"/>.</p>
<p>An equally correct way of interpreting this fixed-point value is to consider it to be an integer with an implied exponent of <img class="formulaInl" alt="$2^{-12}$" src="form_9.png"/>. Fixed-point values are sometimes called <em>scaled integers</em>, where there is an implied scale factor equal to the implied exponent. To convert a fixed-point value to a real number we can view the value as an integer and just divide it by the scale factor. Similarly, to convert a real number to its fixed-point representation we can multiply the real number by its scale factor and discard the fractional part of the result.</p>
<p>Now if a given fixed-point variable has <img class="formulaInl" alt="$I$" src="form_10.png"/> integer bits and <img class="formulaInl" alt="$F$" src="form_11.png"/> fraction bits then the range of real values that can be represented by this variable is <img class="formulaInl" alt="$-2^{I}$" src="form_12.png"/> to <img class="formulaInl" alt="$2^I-2^{-F} \approx 2^I$" src="form_13.png"/>. The resolution of the fixed-point variable (the smallest difference between two values) is <img class="formulaInl" alt="$2^{-F}$" src="form_14.png"/>. Therefore, the range of real numbers that can be represented is determined mainly by <img class="formulaInl" alt="$I$" src="form_10.png"/> and the achievable precision is determined by <img class="formulaInl" alt="$F$" src="form_11.png"/>.</p>
<p>Determining the optimum location for the binary point for a given variable is a compromise between its range and the precision. If we want to keep the same size for the variable then we can either sacrifice precision for a wider range or sacrifice the width of the range in order to get greater precision. However, the penalty for not having enough range is that calculations can overflow and give grossly incorrect results. Therefore, the choice of a binary point location is often made so that overflow cannot possibly occur.</p>
<h1><a class="anchor" id="quick"></a>
A quick example</h1>
<p>This is a quick example of how a floating-point C function can be converted into an equivalent function that uses fixed-point arithmetic with integer operators. For the time being we will ignore many of the details and options.</p>
<p>Suppose we have the following function that converts a voltage from a temperature sensor to the corresponding temperature: </p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sensor(<span class="keywordtype">double</span> InVal)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> Vin, TempC;</div>
<div class="line">  Vin = 3.3 * InVal / 4096.0;</div>
<div class="line">  TempC = Vin * 100.0;</div>
<div class="line">  <span class="keywordflow">return</span> TempC;</div>
<div class="line">}</div>
</div><!-- fragment --><p> We assume that the analog-to-digital converter (ADC) provides a 12-bit integer value ranging from <code>0</code> to <code>4095</code>. Assume that the full-scale range of the ADC is 3.3&#160;V and the temperature sensor scale is 10&#160;mV/&deg;Celsius. The first executable line calculates the actual input voltage, <code>Vin</code>, and the second executable line converts that voltage to a temperature in &deg;C.</p>
<p>Before using the plugin you need to make a small modification to the input file. A requirement for any conversion of floating-point to fixed-point is knowing the fixed-point format of the fixed-point variables. We change the function declaration to indicate that the raw ADC values are actually integers and the 12 bits are right-justified in a 32-bit word, which means that we have 20 redundant sign bits and no fraction bits:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sensor(<span class="keywordtype">double</span> __attribute__ ((fxfrmt(20,12,0))) InVal)</div>
</div><!-- fragment --><p>Installing fxopt can be as simple as copying the <code>fxopt.so</code> file from the repository onto your computer. The plugin is invoked by adding the following switches to the <code>gcc</code> command line:</p>
<ul>
<li><code>-fplugin=/my/full/path/to/fxopt.so</code></li>
<li><code>-fplugin-arg-fxopt-ref-pass-name=ssa</code></li>
<li><code>-fplugin-arg-fxopt-ref-pass-instance-num=1</code></li>
</ul>
<p>If we want to see how fxopt changes the internal representation of the function we can have gcc write out the function just before and after invoking the plugin with these command line switches:</p>
<ul>
<li><code>-fdump-tree-ssa</code></li>
<li><code>-fdump-tree-veclower</code></li>
</ul>
<p>In addition to the usual files generated by gcc we have two extra files, <code>sensor.c.017t.ssa</code> and <code>sensor.c.018t.veclower</code>. Examining the gcc intermediate representation before fxopt runs, in <code>sensor.c.017t.ssa</code>, we find:</p>
<div class="fragment"><div class="line">D.1947_2 = InVal_1(D) * 3.2999999523162841796875e+0;</div>
<div class="line">Vin_3 = D.1947_2 * 2.44140625e-4;</div>
<div class="line">TempC_4 = Vin_3 * 1.0e+2;</div>
</div><!-- fragment --><p>Note that the first executable line of C has been replaced with two lines of code in the intermediate representation, because only a single operation is allowed per statement. The division by 4096.0 has already been converted into a multiplication by its reciprocal, 2.44140625e-4. It's not obvious but the real constants are single-precision floating-point values, which means that they have no more than 24 bits of precision.</p>
<p>The intermediate representation produced by fxopt is found in <code>sensor.c.018t.veclower</code>. The important executable statements from this file are:</p>
<div class="fragment"><div class="line">D.1947_2 = InVal_1(D) * 432538;</div>
<div class="line">_fx_shft1.0_6 = D.1947_2 &gt;&gt; 12;</div>
<div class="line">Vin_3 = _fx_shft1.0_6 * 1;</div>
<div class="line">_fx_shft1.1_7 = Vin_3 &gt;&gt; 7;</div>
<div class="line">TempC_4 = _fx_shft1.1_7 * 100;</div>
</div><!-- fragment --><p>The real constant <code>3.3</code> has been converted to a fixed-point constant with a value of <code>432538</code>. Examining the fxopt transcript we see that the constant is assumed to have 2 integer bits and 17 fraction bits. The real value represented by this constant is <img class="formulaInl" alt="$432538 / 2^{17} = 3.30000305176$" src="form_15.png"/>. Multiplying this constant by <code>InVal</code> (with 12 integer bits and no fraction bits) yields a product with 1 sign bit, 14 integer bits, and 17 fraction bits. This is the most precise result we can get with 32-bit operations.</p>
<p>Fxopt assumes that the constant 2.44140625e-4 is represented with the most advantageous fixed-point format possible. In this case, fxopt assumes that the constant will be represented with 20 sign bits, no integer bits, and 12 fraction bits. Before performing the multiplication fxopt must reformat the variable <code>D.1947_2</code> so that the product will not overflow, and this is accomplished by shifting right 12 bit positions and storing the shifted value in a new variable, <code>_fx_shft1.1_7</code>. Since the 12 least significant fraction bits have been discarded, <code>_fx_shft1.1_7</code> has 13 sign bits, 14 integer bits, and 5 fraction bits. After multiplying by the constant, the product will have 1 sign bit, 14 integer bits, and 17 fraction bits. The multiplication is actually performed in the third statement, where the real fraction is replaced by its fixed-point value of 1 (remember that the equivalent real value is <img class="formulaInl" alt="$1\times 2^{-12}$" src="form_16.png"/> since the constant has 12 fraction bits). Fxopt can actually do a much better job of optimizing this multiplication, as we will see later.</p>
<p>The final calculation, multiplying the input voltage by 100, is performed in the last two statements. Fxopt sees that multiplying the value in <code>Vin</code> by 100 could cause an overflow, so the value of <code>Vin</code> is shifted right 7 places before performing the multiplication.The fixed-point format of the result, <code>TempC</code>, has 1 sign bit, 21 integer bits, and 10 fraction bits.</p>
<p>The intermediate representation produced by fxopt does properly convert the floating-point arithmetic to fixed-point but it is clearly not optimized. This is not only acceptable, it is desirable, because it allows the remaining gcc optimization steps as much freedom as possible to reduce the size and/or execution time of the final object file.</p>
<p>For example, the temperature conversion function was compiled using fxopt with a cross-compiler that targeted the ARM Cortex-M3 architecture. Using the <code>-O2</code> optimization switch results in the assembly code shown below. Note that the trivial multiplication by 1 has been removed, and the two right shift operations have been combined into a single instruction.</p>
<div class="fragment"><div class="line">movw   r3, #39322  ; 0x999a</div>
<div class="line">movt   r3, #6      ; R3 = 0x6999A = 432538</div>
<div class="line">mul.w  r3, r3, r0  ; R3 = InVal * 432538</div>
<div class="line">movs   r0, #100    ; R0 = 100</div>
<div class="line">asrs   r3, r3, #19 ; Vin = R3 &gt;&gt; 19</div>
<div class="line">mul.w  r0, r0, r3  ; TempC = Vin * 100</div>
<div class="line">bx     lr</div>
</div><!-- fragment --><p>At this point it is worth asking about the accuracy of this computation. The maximum difference between the fixed-point calculation and a double-precision floating-point computation is 0.095 &deg;C over all 4096 possible input values. In most applications this level of accuracy is acceptable, particularly when the benefit is 10X to 100X faster execution and smaller code size. If not, then the optional fixed-point accuracy optimization switches can be applied to improve the accuracy to a level that is superior to single-precision floating-point.</p>
<h1><a class="anchor" id="using"></a>
Using fxopt</h1>
<h2><a class="anchor" id="install"></a>
Installing fxopt</h2>
<dl class="section note"><dt>Note</dt><dd>To use the fxopt plugin you must have a version of gcc that supports plugins. Fxopt was originally developed using version 4.6.1 and should work with any version newer than that.</dd></dl>
<p>A compiled version of fxopt is available in the repository, and you may be able to use it directly. To do so you need only download the <code>fxopt.so</code> shared object file.</p>
<p>If you wish to modify and recompile fxopt you will need the gcc source files as well as the source files for fxopt itself. In addition, fxopt uses the hash lists and doubly-linked lists provided by Troy Hanson's <em>uthash</em> package. The source code for this package is available at <a href="https://github.com/troydhanson/uthash">https://github.com/troydhanson/uthash</a>.</p>
<dl class="section note"><dt>Note</dt><dd>I had to edit the <em>uthash</em> code to use <code>xmalloc</code> instead of <code>malloc</code> in the sections of code that creates new hash or list elements.</dd></dl>
<p>Plugins for gcc must be compiled to shared object files, with an <code>.so</code> extension, and an appropriate Makefile for compiling fxopt from the source files is provided in the repository.</p>
<dl class="section note"><dt>Note</dt><dd>If your gcc is a 64-bit executable then fxopt must also be compiled as a 64-bit executable, and if your gcc is a 32-bit executable then fxopt must be compiled as a 32-bit executable. In other words, the version of gcc used to create fxopt must have the same size as the version that executes fxopt.</dd></dl>
<p>A common practice is to compile fxopt itself using a <em>native</em> compiler, so that the fxopt executable has the same binary format as the gcc that was used to compile it, and then to use fxopt with a <em>cross-compiler</em> that produces code for an architecture different than that of the computer used to perform the compilation. For example, you might compile fxopt itself on your desktop computer and then use a cross-compiler to create software for an embedded system. In this scenario both the native compiler and the cross-compiler must have the same type of executable (e.g. an ELF 64-bit LSB executable).</p>
<h2><a class="anchor" id="prep"></a>
Preparing the source file</h2>
<p>A necessary prerequisite for converting floating-point calculations to their fixed-point equivalents is knowing the format of the input parameters, and it is impossible to design a fixed-point calculation without that information. To use fxopt, every function parameter <em>must</em> include a specification for the binary point location.</p>
<p>Fxopt defines a new attribute named <em>fxfrmt</em> that can be used to specify the binary point location for variables as well as their minimum and maximum values. As shown in the example above, C function parameter definitions are modified to add the fxfrmt attribute:</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sensor(<span class="keywordtype">double</span> __attribute__ ((fxfrmt(20,12,0))) InVal)</div>
</div><!-- fragment --><p>The basic syntax for a C attribute is <code>__attribute__ (( ))</code> where the attribute name and parameters are enclosed between the double parentheses. Note that there are two underscores before and after the <code>attribute</code> keyword. The fxfrmt attribute accepts three, four, or five integer parameters, which must be in the specified order:</p>
<ol type="1">
<li>the number of sign bits in the parameter's fixed-point format</li>
<li>the number of integer bits in the format</li>
<li>the number of fraction bits in the format</li>
<li>the maximum possible value of the parameter</li>
<li>the minimum possible value of the parameter</li>
</ol>
<p>If only the first three parameters are supplied then fxopt assumes that the maximum and minimum values of the variable are the maximum and minimum values that can be represented with the specified number of integer and fraction bits.</p>
<dl class="section note"><dt>Note</dt><dd>When the fxfrmt attribute is used as shown here, with three arguments that specify the number of sign, integer, and fraction bits, the variable is assumed to be a <b>signed</b> value. The maximum and minimum values of the variable are assumed to be the maximum and minimum values that can be represented in the specified format. If the function parameter is actually unsigned or is known to have a more restricted range then additional arguments can be provided with the fxfrmt attribute to provide that information to fxopt.</dd></dl>
<p>In some cases the input parameters will be read from some hardware interface, such as an analog-to-digital converter (ADC), which will dictate the format. For example, suppose we have a floating-point function that converts a voltage value from a 12-bit ADC into a Fahrenheit temperature. Assume that the full-scale range of the ADC is 3.3&#160;V and the temperature sensor scale is 10&#160;mV/&deg;Celsius.</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> sensor(<span class="keywordtype">double</span> InVal)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordtype">double</span> Vin, TempC, TempF;</div>
<div class="line"></div>
<div class="line">  Vin = 3.3 * InVal / 4096.0;</div>
<div class="line">  TempC = Vin * 100.0;</div>
<div class="line">  TempF = TempC * 9.0 / 5.0 + 32.0;</div>
<div class="line">  <span class="keywordflow">return</span> TempF;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="run"></a>
Running the compiler</h2>
<p>As with any plugin, fxopt is enabled by adding switches to the command line when invoking gcc. There are three command line switches that must be used to activate the plugin: </p>
<ul>
<li><b><code>-fplugin=/the_path_to_the_plugin/fxopt.so</code></b> provides a complete path to the shared object file for the plugin </li>
<li><b><code>-fplugin-arg-fxopt-ref-pass-name=ssa</code></b> specifies that the plugin should be run after the optimization pass that converts the input source code to the static-single-assignment (SSA) form </li>
<li><b><code>-fplugin-arg-fxopt-ref-pass-instance-num=1</code></b> specifies that the plugin should be run after the SSA pass runs for the first time</li>
</ul>
<h2><a class="anchor" id="options"></a>
Controlling the conversion process</h2>
<p>Range estimation is a powerful method for improving the quality of the fixed-point computations produced by fxopt. Determining a variable's largest possible magnitude allows fxopt to optimize the fixed-point format of that variable and maintain the greatest accuracy. Because fxopt was created as a research tool, its default mode of operation does not perform range estimation and only the fixed-point <em>formats</em> of the operands are used to determine a format for the result of an operation, such that no overflow can occur. Better results can be had by enabling one of the range estimation techniques described below.</p>
<ul>
<li><p><b><code>-fplugin-arg-fxopt-interval</code></b> The interval option enables the use of interval arithmetic to determine the possible range of all operands. Interval arithmetic determines the range of the result of an operation using the minimum and maximum possible values of the operands.</p>
<p>For example, suppose that <code>InVal</code> is an 8-bit, signed input parameter to a function and fxopt knows that it has 1 sign bit, no integer bits, and 7 fraction bits. Suppose we have calculations like: </p>
<div class="fragment"><div class="line">Pi  = 3.14;</div>
<div class="line">Bar = 2.5;</div>
<div class="line">Foo = Pi * Bar * InVal;</div>
</div><!-- fragment --><p> The variables <code>Pi</code> and <code>Bar</code> will both require 2 integer bits for their fixed-point representations. Based solely on the format information and our understanding of how multiplication works, we would expect that <code>Foo</code> would require 4 integer bits.</p>
<p>When interval arithmetic is enabled, fxopt's internal specification of every variable includes not only its fixed-point format information but also the minimum and maximum possible values of that variable. The range of the result of a simple arithmetic operation can be determined easily, given the ranges of the operands. In this example, <code>Pi</code> has a range of [3.14,3.14] and the range of <code>Bar</code> is [2.5,2.5]. Based solely on its fixed-point format, <code>InVal</code> has a range a [0x80,0x7F] which is equivalent to a real number range of [-1.0,0.9921875]. The range of <code>Foo</code> is easily calculated to be [-7.85,7.788671875]. Now we see that only 3 integer bits are required in the fixed-point representation of <code>Foo</code>.</p>
<p>Since the number of bits in a variable is fixed, reducing the number of integer bits required allows us to increase the number of fraction bits. This increases the available resolution of a fixed-point variable and typically improves the accuracy of computations.</p>
<p></p>
</li>
</ul>
<ul>
<li><p><b><code>-fplugin-arg-fxopt-affine</code></b> The affine option enables the use of affine arithmetic to determine the range of all operands. With this option enabled, fxopt determines an equation for each variable that expresses its value as a linear function of the input variables and known constants. Affine range estimates exploit the correlation that occurs when the same input variables appear in the affine definitions for the operands of an arithmetic operation. Non-affine operations, such as multiplication and division, introduce error terms. Nevertheless, affine range estimates are often more accurate than those determined using simple interval arithmetic.</p>
<p>For example, suppose that <code>InVal</code> is an 8-bit, signed input parameter to a function and fxopt knows that it has 1 sign bit and 7 fraction bits. This variable's range is [0x80,0x7F] which is equivalent to a real number range of [-1.0,0.9921875]. Suppose we have calculations like: </p>
<div class="fragment"><div class="line">Foo = 5 * InVal - 3;</div>
<div class="line">Bar = Foo - InVal;</div>
</div><!-- fragment --><p> Within gcc this code is converted into 3 primitive operations: </p>
<div class="fragment"><div class="line">Temp = 5 * InVal;</div>
<div class="line">Foo = Temp - 3;</div>
<div class="line">Bar = Foo - InVal;</div>
</div><!-- fragment --><p>If simple interval arithmetic is used, the range of <code>Temp</code> is first determined to be [-5.0,4.9609375]. Subtracting 3 gives <code>Foo</code> a range of [-8.0,1.9609375]. Finally, subtracting <code>InVal</code>, with its range of [-1.0,0.9921875], is equivalent to adding a range of [-0.9921875,1.0] and leaves <code>Bar</code> with a range of [-8.9921875,2.9609375].</p>
<p>By using affine arithmetic, fxopt recognizes that <code>Bar</code> is equal to (4&#160;*&#160;InVal)-3 and assigns this variable a range of [-7.0,0.96875]. If interval arithmetic is used we need to allocate 4 bits to represent the integer part of <code>Bar</code>, but with affine arithmetic we see that only 3 bits are actually needed. The bit that was freed from the integer portion of <code>Bar</code> can be used instead to increase its fractional resolution. In practice, increased resolution leads to improved accuracy in the computations.</p>
<p></p>
</li>
</ul>
<p>While range estimation improves the accuracy of the fixed-point computations with little or no run-time penalty, there are other trade-offs that can increase accuracy only at the cost of increased execution time and executable code size. Several command-line switches can be used when executing gcc to allow fxopt to add additional instructions in certain situations to improve accuracy. By default, these options are disabled.</p>
<ul>
<li><p><b><code>-fplugin-arg-fxopt-round</code></b> When enabled, this option causes rounding to be performed with a run-time adjustment for signed, negative values. For example, a shift operation without rounding might be: </p>
<div class="fragment"><div class="line">fx_shft1 = SomeVariable &gt;&gt; 8;</div>
</div><!-- fragment --><p> (Note that the right shift operator used in gcc's intermediate format is an arithmetic shift that preserves the sign of signed operands, unlike the same operator in C.)</p>
<p>The error introduced by this truncation can be greatly reduced by adding a constant equal to one-half the value of the least-significant bit of the shifted value. The value of this constant can be determined at compile time, since the size of the shift is also known at compile time, so this rounding step requires just one additional statement to add the constant. </p>
<div class="fragment"><div class="line">fx_shft1 = (SomeVariable + (1 &lt;&lt; 7)) &gt;&gt; 8;</div>
</div><!-- fragment --><p>However, this rounding method does not produce the desired result when the original value is negative and the truncated bits are exactly equal to one half of the remaining LSB. To eliminate the error from this (admittedly rare) case, a run-time adjustment is done. If the variable being shifted is negative then a signed integer value of 1 must be subtracted before truncation, thereby ensuring that the variable will be rounded toward negative infinity rather than toward 0. It is generally desirable to avoid conditional instructions (such as testing the variable's sign) so fxopt will instead add a value of -1 if the variable is negative. By shifting the original variable right we can obtain a value that will be -1 if the variable is negative or 0 if the variable is positive, and then this value can be unconditionally added to the variable. Note that this rounding procedure requires the insertion of a shift operation and two addition operations. </p>
<div class="fragment"><div class="line">fx_sign  = SomeVariable &gt;&gt; (size_of(SomeVariable) - 1);</div>
<div class="line">fx_shft1 = (SomeVariable + (1 &lt;&lt; 7) + fx_sign) &gt;&gt; 8;</div>
</div><!-- fragment --> </li>
</ul>
<ul>
<li><b><code>-fplugin-arg-fxopt-round-positive</code></b> This option causes fxopt to assume that any quantity to be rounded is non-negative. The run-time adjustment for negative values (described above) is never added to the executable code, which can significantly reduce the code size and execution time of the fixed-point computations. However, eliminating this adjustment can introduce a small bias, or offset, into the data that may reduce the accuracy of the final results.</li>
</ul>
<ul>
<li><p><b><code>-fplugin-arg-fxopt-guard</code></b> Since rounding is performed by adding a constant to a value before truncation, it is possible that an overflow can occur when the constant is added. Enabling this option causes fxopt to determine whether a given rounding operation might cause an overflow, and to prevent that overflow by creating a redundant sign bit (a <em>guard</em> bit). To create the guard bit, fxopt inserts a right shift of 1 bit position before the rounding step.</p>
<p>For example, shifting <code>SomeVariable</code> right by 8 bit positions, with rounding, is equivalent to this statement: </p>
<div class="fragment"><div class="line">fx_shft1 = (SomeVariable + (1 &lt;&lt; 7)) &gt;&gt; 8;</div>
</div><!-- fragment --><p> If the guard option is enabled and fxopt determines that the addition step in this statement might cause an overflow, then the rounding operation will instead be performed as: </p>
<div class="fragment"><div class="line">fx_shft2 = SomeVariable &gt;&gt; 1;</div>
<div class="line">fx_shft1 = (fx_shft2 + (1 &lt;&lt; 6)) &gt;&gt; 7;</div>
</div><!-- fragment --><p>The disadvantage of using the guard option is that an additional run-time operation is added to the rounding step. Since guarding is only required when fxopt determines that rounding <em>might</em> cause an overflow, a robust range analysis of the operands can often prevent it from being necessary. </p>
</li>
</ul>
<ul>
<li><p><b><code>-fplugin-arg-fxopt-dpmult</code></b> The dpmult option instructs fxopt to use a double-precision multiplication operation. By default, all floating-point operands are converted to integer operands of the same size and the integer multiplication operator returns a result of that size. Binary multiplication naturally produces a result that has twice as many bits as the operands, so the single-precision multiplication operation effectively discards the upper half of the result. To ensure that the result of a single-precision multiplication is valid, fxopt must therefore reduce the precision of the operands <em>before</em> performing the multiplication.</p>
<p>For example, if 32-bit integers are used then the floating-point statement: </p>
<div class="fragment"><div class="line">Product = Multiplier * Multiplicand;</div>
</div><!-- fragment --><p> might be converted to fixed-point as: </p>
<div class="fragment"><div class="line">fx_shft1 = Multiplier &gt;&gt; 16;</div>
<div class="line">fx_shft2 = Multiplicand &gt;&gt; 16;</div>
<div class="line">Product = fx_shft1 * fx_shft2;</div>
</div><!-- fragment --><p> Enabling double-precision multiplications would instead convert the floating-point multiplication to something like: </p>
<div class="fragment"><div class="line">fx_wide = Multiplier w* Multiplicand;</div>
<div class="line">Product = fx_wide &gt;&gt; 32;</div>
</div><!-- fragment --><p> where <code>w*</code> is the "wide multiply" operator used internally by gcc.</p>
<p>The effect of double-precision multiplication on the execution time of the converted computations can vary greatly, depending upon the relative execution time of multiplication and shifting in the target processor. However, using single-precision multiplication can lead to serious degradation in the accuracy of the results.</p>
<p>Note that even when the dpmult option is enabled, fxopt detects circumstances where using a double-precision multiplication provides no accuracy benefit and reverts to a single-precision multiplication in those situations. This is often the case when the multiplier is a small constant. </p>
</li>
</ul>
<ul>
<li><b><code>-fplugin-arg-fxopt-div2mult</code></b> Enabling this option will cause fxopt to convert all division operations with a constant divisor to multiplication by a constant multiplier. While gcc often performs this conversion automatically for integer operations it may not be done by default for floating-point operations. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Apr 22 2014 19:02:48 for fxopt by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
